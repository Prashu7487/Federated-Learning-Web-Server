Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from fastapi import FastAPI, BackgroundTasks, Request, HTTPException, WebSocket, WebSocketDisconnect\r\nfrom schema import FederatedLearningInfo, User, Parameter, CreateFederatedLearning, ClientFederatedResponse, \\\r\n    ClientReceiveParameters\r\nfrom fastapi.middleware.cors import CORSMiddleware\r\nfrom sse_starlette.sse import EventSourceResponse\r\nfrom utility.FederatedLearning import FederatedLearning\r\nfrom utility.ConnectManager import ConnectionManager\r\nfrom utility.Server import Server\r\nimport asyncio\r\nimport json\r\nimport asyncio\r\nimport uuid\r\nfrom utility.test import Test\r\n\r\n'''\r\n    Naming Conventions as per PEP- https://peps.python.org/pep-0008/#function-and-variable-names\r\n    Classes - CapWords Convention\r\n    Methods - Function names should be lowercase, with words separated by underscores as necessary to improve readability.\r\n    Variables - Variable names follow the same convention as function names.\r\n'''\r\n\r\nevent = asyncio.Event()\r\n\r\napp = FastAPI()\r\n\r\napp.add_middleware(\r\n    CORSMiddleware,\r\n    allow_origins=[\"*\"],\r\n    allow_credentials=True,\r\n    allow_methods=[\"*\"],\r\n    allow_headers=[\"*\"],\r\n)\r\n\r\nclients_data = []\r\n\r\n\r\nclass MessageType:\r\n    GET_MODEL_PARAMETERS_START_BACKGROUND_PROCESS = \"get_model_parameters_start_background_process\"\r\n    START_TRAINING = \"start_training\"\r\n\r\n\r\n# Utility Function\r\ndef generate_unique_token():\r\n    token = str(uuid.uuid4())\r\n    return token\r\n\r\n\r\ndef generate_session_token():\r\n    session_token = generate_unique_token()\r\n    # Check if token is already assigned to other federated session\r\n    return session_token\r\n\r\n\r\ndef generate_user_token():\r\n    user_token = generate_unique_token()\r\n    # Check if token is already assigned to other federated session\r\n    return user_token\r\n\r\n\r\n# Usage\r\nfederated_manager = FederatedLearning()\r\nconnection_manager = ConnectionManager()\r\n\r\n\r\nasync def wait_for_client_confirmation(session_id: str):\r\n    session_data = federated_manager.federated_sessions[session_id]\r\n    all_ready_for_training = False\r\n\r\n    while not all_ready_for_training:\r\n        await asyncio.sleep(5)\r\n        all_ready_for_training = all(client['status'] != 1 for client in session_data['clients_status'].values())\r\n        print(\"Waiting for client confirmations....Stage 1\")\r\n\r\n    print(\"All Clients have taken their decision.\")\r\n\r\n\r\nasync def send_message_with_type(client_id: str, message_type: str, data: dict, session_id: str):\r\n    message = {\r\n        \"type\": message_type,\r\n        \"data\": data,\r\n        \"session_id\": session_id\r\n    }\r\n    json_message = json.dumps(message)\r\n    print(\"json model sent before the training signal: \", json_message)\r\n    await connection_manager.send_message(json_message, client_id)\r\n\r\n\r\nasync def send_model_configuration(client_id: str, session_id: str):\r\n    model_data = federated_manager.federated_sessions[session_id]\r\n    model_config = model_data['federated_info']\r\n    model_config_dict = model_config.dict()  # Convert to dictionary\r\n    await send_message_with_type(client_id, MessageType.GET_MODEL_PARAMETERS_START_BACKGROUND_PROCESS,\r\n                                 model_config_dict, session_id)\r\n\r\n\r\nasync def wait_for_all_clients_to_stage_four(session_id: str):\r\n    # Implement the logic to wait for all clients to confirm that they have started background process\r\n    session_data = federated_manager.federated_sessions[session_id]\r\n    interested_clients = session_data['interested_clients']\r\n\r\n    while True:\r\n        all_clients_ready = True\r\n        for client_id in interested_clients:\r\n            if session_data['clients_status'][client_id]['status'] != 4:\r\n                all_clients_ready = False\r\n                break\r\n\r\n        if all_clients_ready:\r\n            print(\"All clients have reached stage four.\")\r\n            break\r\n        else:\r\n            await asyncio.sleep(5)\r\n            print(\"Waiting for all clients to reach stage four.\", federated_manager.federated_sessions.keys())\r\n\r\n\r\nasync def send_model_configs_and_wait_for_confirmation(session_id: str):\r\n    interested_clients = federated_manager.federated_sessions[session_id]['interested_clients']\r\n    for client in interested_clients:\r\n        await send_model_configuration(client, session_id)\r\n\r\n    # Wait for all clients to confirm they have started their background process\r\n    await wait_for_all_clients_to_stage_four(session_id)\r\n\r\n\r\nasync def send_training_signal_to_clients(session_id: str):\r\n    session_data = federated_manager.federated_sessions[session_id]\r\n    interested_clients = session_data['interested_clients']\r\n    data = {\r\n        'session_id': session_id  #dummy data, not accesses at client side\r\n    }\r\n    print(\"Before Sending Signal : \", federated_manager.federated_sessions[session_id])\r\n    for client_id in interested_clients:\r\n        print(client_id)\r\n        await send_message_with_type(client_id, MessageType.START_TRAINING, data,\r\n                                     session_id)  #session_id is dummy data here\r\n    print(\"Training Signal Sent to all clients\")\r\n\r\n\r\nasync def send_training_signal_and_wait_for_clients_training(session_id: str):\r\n    await send_training_signal_to_clients(session_id)\r\n\r\n    session_data = federated_manager.federated_sessions[session_id]\r\n    num_interested_clients = len(session_data['interested_clients'])\r\n    print(\"Error Check : \", len(session_data['client_parameters']), num_interested_clients)\r\n    while len(session_data['client_parameters']) < num_interested_clients:\r\n        await asyncio.sleep(5)\r\n        print(f\"Waiting for {num_interested_clients - len(session_data['client_parameters'])}\")\r\n\r\n    # print(\"All clients have sent parameters. Starting Aggregation...\", session_data['client_parameters'])\r\n\r\n\r\nasync def start_federated_learning(session_id: str):\r\n    \"\"\"\r\n    Background task to manage federated learning rounds.\r\n\r\n    This function runs in the background, waiting for client responses before proceeding with each round\r\n    of federated learning.\r\n\r\n    Each round consists of:\r\n    1. Setting the current round number (`curr_round`) in the server.\r\n    2. Printing round information.\r\n    3. Receiving parameters from clients.\r\n    4. Aggregating weights using federated averaging with neural networks.\r\n\r\n    \"\"\"\r\n    try:\r\n        session_data = federated_manager.federated_sessions[\r\n            session_id]  # session_data points to same object variables in Python that point to mutable objects (like dictionaries) actually reference the same underlying object in memory.\r\n\r\n        # Wait for client confirmation of interest\r\n        await wait_for_client_confirmation(session_id)\r\n\r\n        # Send Model Configurations to interested clients and wait for their confirmation\r\n        await send_model_configs_and_wait_for_confirmation(session_id)\r\n\r\n        #############################################\r\n        # code used to get instance of testing unit\r\n        # Here Input has to be taken in future for the metrics\r\n        test = Test(session_id, session_data)\r\n        #############################################\r\n\r\n        # Start Training\r\n        for i in range(1, session_data['max_round'] + 1):\r\n            print(\"-\" * 50)\r\n            federated_manager.federated_sessions[session_id]['curr_round'] = i\r\n            print(f\"Round {i}\")\r\n            print(\"-\" * 50)\r\n\r\n            await send_training_signal_and_wait_for_clients_training(session_id)\r\n            # Aggregate\r\n            print(\"Done upto just before aggregation...\")\r\n            federated_manager.aggregate_weights_fedAvg_Neural(session_id)\r\n\r\n            ################## Testing start\r\n            results = test.start_test(federated_manager.federated_sessions[session_id]['global_parameters'])\r\n            print(\"Global test results: \", results)\r\n            ################## Testing end\r\n\r\n        # Save test results for future reference\r\n        \"\"\" Yashvir: here you can delete the data of this session from the federated_sessions dictionary after saving the results \r\n            , saved results contains session_data and test_results across all rounds\r\n        \"\"\"\r\n        test.save_test_results()\r\n    except Exception as e:\r\n        print(f\"Error in Starting Background Process: {e}\")\r\n\r\n\r\ndef add_interested_user_to_session(client_token, session_token: str, request: Request, admin):\r\n    \"\"\"\r\n    Generates a token for user which will be used to validate the sender, and the token will be bound to a spefic session.\r\n    :param client_token: This will be authentication token for a user in future when establish authentication each user has a unique user_id\r\n    :param session_token: This will be unique token for each session\r\n    :param admin: This user is admin of this request or not\r\n    :param request:\r\n    :return:\r\n    \"\"\"\r\n    federated_manager.federated_sessions[session_token]['clients_status'][client_token]['status'] = 2\r\n    federated_manager.federated_sessions[session_token][\"interested_clients\"][client_token] = {\r\n        \"ip\": request.client.host,\r\n    }\r\n    if admin:\r\n        federated_manager.federated_sessions[session_token][\"admin\"] = client_token\r\n\r\n\r\n@app.websocket(\"/ws/{client_id}\")\r\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\r\n    await connection_manager.connect(websocket, client_id)\r\n    try:\r\n        while True:\r\n            data = await websocket.receive_text()\r\n            print(data)\r\n\r\n    except WebSocketDisconnect:\r\n        connection_manager.disconnect(client_id)\r\n        print(f\"Client {client_id} disconnected\")\r\n\r\n\r\n@app.post('/sign-in')\r\ndef signIn(request: User):\r\n    user_token = generate_user_token()\r\n    clients_data.append(user_token)\r\n    print(f\"{request.name} is registered\")\r\n    return {\"message\": \"Client Registered Successfully\", \"client_token\": user_token}\r\n\r\n\r\n@app.post(\"/create-federated-session\")\r\ndef create_federated_session(federated_details: CreateFederatedLearning, request: Request,\r\n                             background_tasks: BackgroundTasks):\r\n    session_token = generate_session_token()\r\n    federated_manager.create_federated_session(session_token, federated_details.fed_info, clients_data)\r\n\r\n    add_interested_user_to_session(federated_details.client_token, session_token, request, admin=True)\r\n    try:\r\n        background_tasks.add_task(start_federated_learning, session_token)\r\n        print(\"Background Task Added\")\r\n    except Exception as e:\r\n        print(f\"An error occurred while adding background process {Exception}\")\r\n        return {\"message\": \"An error occurred while starting federated learning.\"}\r\n\r\n    return {\"message\": \"Federated Session has been created!\"}\r\n\r\n\r\n@app.get('/get-all-federated-sessions')\r\ndef get_all_federated_session():\r\n    federated_session = []\r\n    for session_id, session_data in federated_manager.federated_sessions.items():\r\n        federated_session.append({\r\n            'session_id': session_id,\r\n            \"training_status\": session_data[\"training_status\"]\r\n        })\r\n    return {\"federated_session\": federated_session}\r\n\r\n\r\n@app.get('/get-federated-session/{session_id}')\r\ndef get_federated_session(session_id: str, client_id: str):\r\n    first_session_key = list(federated_manager.federated_sessions.keys())[0]\r\n    try:\r\n        federated_session_data = federated_manager.federated_sessions[session_id]\r\n        federated_response = {\r\n            'federated_info': federated_session_data['federated_info'],\r\n            'training_status': federated_session_data['training_status'],\r\n            'client_status': federated_session_data['clients_status'][client_id]['status']\r\n        }\r\n        return federated_response\r\n    except KeyError:\r\n        raise HTTPException(status_code=404, detail=\"Session not found\")\r\n    except Exception as e:\r\n        raise HTTPException(status_code=500, detail=f\"An error occurred: {str(e)}\")\r\n\r\n\r\n@app.post('/submit-client-federated-response')\r\ndef submit_client_federated_response(client_response: ClientFederatedResponse, request: Request):\r\n    '''\r\n        decision : 1 means client accepts and 0 means rejects\r\n        client_status = 2 means client has accepted the request\r\n        client_status = 3 means client rejected the request\r\n    '''\r\n    try:\r\n        session_id = client_response.session_id\r\n        client_id = client_response.client_id\r\n        decision = client_response.decision\r\n        if decision == 1:\r\n            federated_manager.federated_sessions[session_id]['clients_status'][client_id]['status'] = 2\r\n            add_interested_user_to_session(client_id, session_id, request, admin=False)\r\n        else:\r\n            federated_manager.federated_sessions[session_id]['clients_status'][client_id]['status'] = 3\r\n        return {'message': 'Client Decision has been saved'}\r\n    except Exception as e:\r\n        raise HTTPException(status_code=500, detail=f\"An error occurred: {str(e)}\")\r\n\r\n\r\n@app.post('/update-client-status-four')\r\ndef update_client_status_four(request: ClientFederatedResponse):\r\n    '''\r\n        Client have received the model parameters and waiting for server to start training\r\n    '''\r\n    client_id = request.client_id\r\n    session_id = request.session_id\r\n    federated_manager.federated_sessions[session_id]['clients_status'][client_id]['status'] = 4\r\n    return {'message': 'Client Status Updated to 4'}\r\n\r\n\r\n@app.get('/get-model-parameters/{session_id}')\r\ndef get_model_parameters(session_id: str):\r\n    '''\r\n        Client have received the model parameters and waiting for server to start training\r\n    '''\r\n    global_parameters = federated_manager.federated_sessions[session_id]['global_parameters']\r\n    response_data = {\r\n        \"global_parameters\": global_parameters,\r\n        \"is_first\": 0\r\n    }\r\n    if len(global_parameters) == 0:\r\n        response_data['is_first'] = 1\r\n    return response_data\r\n\r\n\r\n@app.post('/receive-client-parameters')\r\ndef receive_client_parameters(request: ClientReceiveParameters):\r\n    session_id = request.session_id\r\n    client_id = request.client_id\r\n    federated_manager.federated_sessions[session_id]['client_parameters'][client_id] = request.client_parameter\r\n    return {\"message\": \"Client Parameters Received\"}\r\n\r\n\r\n################ end point to test working server ############\r\n\r\n@app.get('/test')\r\ndef test_server():\r\n    return {\"message\": \"Server is started...\"}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	(revision 348ca25e497b61e14244deff56bac824332027da)
+++ b/main.py	(date 1721898632716)
@@ -2,6 +2,7 @@
 from schema import FederatedLearningInfo, User, Parameter, CreateFederatedLearning, ClientFederatedResponse, \
     ClientReceiveParameters
 from fastapi.middleware.cors import CORSMiddleware
+from starlette.middleware.cors import CORSMiddleware
 from sse_starlette.sse import EventSourceResponse
 from utility.FederatedLearning import FederatedLearning
 from utility.ConnectManager import ConnectionManager
